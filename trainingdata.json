[
    {
        "input": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport 'openzeppelin-contracts/token/ERC721/ERC721.sol';\nimport './Project.sol';\n\n\ncontract CrowdFunder is ERC721 {\n\n    address immutable project;\n    uint private _currentTokenId = 0;\n\n    modifier onlyProject () {\n        require(msg.sender == address(project), 'Only project can call this function');\n        _;\n    }\n\n    constructor (string memory name, string memory symbol) ERC721(name, symbol) {\n        project = msg.sender;\n    }\n\n    function mint (address to) public onlyProject() {\n        _safeMint(to, _currentTokenId); /* PLEASE HIT THIS LINE */\n        _currentTokenId++;  /* PLEASE HIT THIS LINE */\n    }\n\n    function recieve() public payable {\n    }\n}",
        "output": "function testMint() public {\n        vm.startPrank(alice);\n        CrowdFunder crowdFunder = new CrowdFunder('CrowdFunder', 'CRF');\n        crowdFunder.mint(bob);\n        vm.stopPrank();\n    }"
    },
    {
        "input": "// SPDX-License-Identifier: UNLICENSED\nimport './Project.sol';\n\npragma solidity ^0.8.13;\n\ncontract ProjectFactory {\n\n    function create(uint _goal, string memory _name, string memory _symbol) external returns (address) {\n        return address(new Project(_goal, _name, _symbol, msg.sender)); /* PLEASE HIT THIS LINE */\n    }\n}",
        "output": "function testCreate() public {\n        vm.startPrank(alice);\n        ProjectFactory factory = new ProjectFactory();\n        factory.create(100, 'Project', 'PRJ');\n        vm.stopPrank();\n    }"
    },
    {
        "input": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport './CrowdFunder.sol';\nimport 'forge-std/console.sol';\n\ncontract Project {\n\n    address public immutable creator;\n    \n    uint public immutable goal;\n    uint timeCreated = block.timestamp;\n\n    bool public goalFailed = false;\n    bool public goalAchieved = false;\n    \n    CrowdFunder nft;\n\n    mapping (address => uint) public contributions;\n    mapping (address => uint) public tokensOwed;\n    mapping (address => uint) public tokensClaimed;\n\n    modifier onlyCreator() {\n        require(msg.sender == creator, 'Only creator can call this function');\n        _;\n    }\n\n    function setGoalStatus() private {\n        if(goalAchieved || goalFailed) {\n            return;\n        } else if (block.timestamp > timeCreated + 30 days) {\n            goalFailed = true;\n        } else if (address(this).balance >= goal) {\n            goalAchieved = true;\n        }\n    }\n\n    constructor (uint _goal, string memory _name, string memory _symbol, address _creator) {\n        goal = _goal;\n        nft = new CrowdFunder(_name, _symbol);\n        creator = _creator;\n    }\n\n    function contribute () public payable {\n        \n        if (block.timestamp > timeCreated + 30 days) {\n            goalFailed = true;\n        } \n        \n        require(msg.value >= 0.01 ether, 'Not enough eth'); /* PLEASE HIT THIS LINE */\n        require(!(goalAchieved || goalFailed), 'Goal already achieved or failed'); /* PLEASE HIT THIS LINE */\n        contributions[msg.sender] += msg.value; /* PLEASE HIT THIS LINE */\n\n        tokensOwed[msg.sender] = contributions[msg.sender] / 1 ether; /* PLEASE HIT THIS LINE */\n\n        setGoalStatus(); /* PLEASE HIT THIS LINE */\n    }\n\n    function claimTokens () public  {\n        setGoalStatus();\n        uint numTokensToMint = tokensOwed[msg.sender] - tokensClaimed[msg.sender];\n        tokensClaimed[msg.sender] += numTokensToMint;\n        for (uint i = 0; i < numTokensToMint; i++) {\n            nft.mint(msg.sender);\n        }\n    }\n\n    function refund () public  {\n        setGoalStatus();\n        require(contributions[msg.sender] > 0, 'No contribution to refund');\n        require(goalFailed, 'Goal not failed');\n        uint refundAmount = contributions[msg.sender];\n        contributions[msg.sender] = 0;\n        (bool success,) = payable(msg.sender).call{value: refundAmount}('');\n        require(success, 'Refund failed');\n    }  \n\n    function withdraw(uint amount) public onlyCreator() {\n        setGoalStatus();\n        require(goalAchieved, 'Goal not achieved');\n        require(amount <= address(this).balance, 'Not enough eth');\n        (bool success,) = payable(creator).call{value: amount}('');\n        require(success, 'Withdraw failed');\n    }\n\n    receive() external payable {\n        contribute();\n    }\n}",
        "output":  "function testContributeSucess() public {\n        \n        vm.startPrank(bob);\n        Project project = new Project(50 ether, 'Project', 'PJT', bob);\n        vm.stopPrank();\n\n        vm.deal(alice, 100 ether);\n\n        vm.startPrank(alice);\n        project.contribute{value: 10 ether}();\n        vm.stopPrank();\n    \n    }"
    },
    {
        "input": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport './CrowdFunder.sol';\nimport 'forge-std/console.sol';\n\ncontract Project {\n\n    address public immutable creator;\n    \n    uint public immutable goal;\n    uint timeCreated = block.timestamp;\n\n    bool public goalFailed = false;\n    bool public goalAchieved = false;\n    \n    CrowdFunder nft;\n\n    mapping (address => uint) public contributions;\n    mapping (address => uint) public tokensOwed;\n    mapping (address => uint) public tokensClaimed;\n\n    modifier onlyCreator() {\n        require(msg.sender == creator, 'Only creator can call this function');\n        _;\n    }\n\n    function setGoalStatus() private {\n        if(goalAchieved || goalFailed) {\n            return;\n        } else if (block.timestamp > timeCreated + 30 days) {\n            goalFailed = true;\n        } else if (address(this).balance >= goal) {\n            goalAchieved = true;\n        }\n    }\n\n    constructor (uint _goal, string memory _name, string memory _symbol, address _creator) {\n        goal = _goal;\n        nft = new CrowdFunder(_name, _symbol);\n        creator = _creator;\n    }\n\n    function contribute () public payable {\n        \n        if (block.timestamp > timeCreated + 30 days) { /* PLEASE HIT THIS LINE */\n            goalFailed = true; /* PLEASE HIT THIS LINE */\n        } \n        \n        require(msg.value >= 0.01 ether, 'Not enough eth');\n        require(!(goalAchieved || goalFailed), 'Goal already achieved or failed');\n        contributions[msg.sender] += msg.value;\n\n        tokensOwed[msg.sender] = contributions[msg.sender] / 1 ether;\n\n        setGoalStatus();\n    }\n\n    function claimTokens () public  {\n        setGoalStatus();\n        uint numTokensToMint = tokensOwed[msg.sender] - tokensClaimed[msg.sender];\n        tokensClaimed[msg.sender] += numTokensToMint;\n        for (uint i = 0; i < numTokensToMint; i++) {\n            nft.mint(msg.sender);\n        }\n    }\n\n    function refund () public  {\n        setGoalStatus();\n        require(contributions[msg.sender] > 0, 'No contribution to refund');\n        require(goalFailed, 'Goal not failed');\n        uint refundAmount = contributions[msg.sender];\n        contributions[msg.sender] = 0;\n        (bool success,) = payable(msg.sender).call{value: refundAmount}('');\n        require(success, 'Refund failed');\n    }  \n\n    function withdraw(uint amount) public onlyCreator() {\n        setGoalStatus();\n        require(goalAchieved, 'Goal not achieved');\n        require(amount <= address(this).balance, 'Not enough eth');\n        (bool success,) = payable(creator).call{value: amount}('');\n        require(success, 'Withdraw failed');\n    }\n\n    receive() external payable {\n        contribute();\n    }\n}",
        "output": "function testContributeGoalFailed() public {\n        vm.startPrank(bob);\n        Project project = new Project(50 ether, 'Project', 'PJT', bob);\n        vm.stopPrank();\n\n        vm.deal(alice, 100 ether);\n        vm.warp(block.timestamp + 31 days);\n        \n        vm.startPrank(alice);\n        vm.expectRevert('Goal already achieved or failed');\n        project.contribute{value: 10 ether}();\n        vm.stopPrank(); \n    }"
    },
    {
        "input": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport './CrowdFunder.sol';\nimport 'forge-std/console.sol';\n\ncontract Project {\n\n    address public immutable creator;\n    \n    uint public immutable goal;\n    uint timeCreated = block.timestamp;\n\n    bool public goalFailed = false;\n    bool public goalAchieved = false;\n    \n    CrowdFunder nft;\n\n    mapping (address => uint) public contributions;\n    mapping (address => uint) public tokensOwed;\n    mapping (address => uint) public tokensClaimed;\n\n    modifier onlyCreator() {\n        require(msg.sender == creator, 'Only creator can call this function');\n        _;\n    }\n\n    function setGoalStatus() private {\n        if(goalAchieved || goalFailed) {\n            return;\n        } else if (block.timestamp > timeCreated + 30 days) {\n            goalFailed = true;\n        } else if (address(this).balance >= goal) {\n            goalAchieved = true;\n        }\n    }\n\n    constructor (uint _goal, string memory _name, string memory _symbol, address _creator) {\n        goal = _goal;\n        nft = new CrowdFunder(_name, _symbol);\n        creator = _creator;\n    }\n\n    function contribute () public payable {\n        \n        if (block.timestamp > timeCreated + 30 days) {\n            goalFailed = true;\n        } \n        \n        require(msg.value >= 0.01 ether, 'Not enough eth');\n        require(!(goalAchieved || goalFailed), 'Goal already achieved or failed');\n        contributions[msg.sender] += msg.value;\n\n        tokensOwed[msg.sender] = contributions[msg.sender] / 1 ether;\n\n        setGoalStatus();\n    }\n\n    function claimTokens () public  {\n        setGoalStatus();\n        uint numTokensToMint = tokensOwed[msg.sender] - tokensClaimed[msg.sender];\n        tokensClaimed[msg.sender] += numTokensToMint;\n        for (uint i = 0; i < numTokensToMint; i++) { /* PLEASE HIT THIS LINE */\n            nft.mint(msg.sender); /* PLEASE HIT THIS LINE */\n        }\n    }\n\n    function refund () public  {\n        setGoalStatus();\n        require(contributions[msg.sender] > 0, 'No contribution to refund');\n        require(goalFailed, 'Goal not failed');\n        uint refundAmount = contributions[msg.sender];\n        contributions[msg.sender] = 0;\n        (bool success,) = payable(msg.sender).call{value: refundAmount}('');\n        require(success, 'Refund failed');\n    }  \n\n    function withdraw(uint amount) public onlyCreator() {\n        setGoalStatus();\n        require(goalAchieved, 'Goal not achieved');\n        require(amount <= address(this).balance, 'Not enough eth');\n        (bool success,) = payable(creator).call{value: amount}('');\n        require(success, 'Withdraw failed');\n    }\n\n    receive() external payable {\n        contribute();\n    }\n}",
        "output": "function testClaimTokensSuccess() public {\n        vm.startPrank(bob);\n        Project project = new Project(50 ether, 'Project', 'PJT', bob);\n        vm.stopPrank();\n\n        vm.deal(alice, 100 ether);\n\n        vm.startPrank(alice);\n        project.contribute{value: 10 ether}();\n        project.claimTokens();\n        vm.stopPrank();\n    }"
    },
    {
        "input": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport './CrowdFunder.sol';\nimport 'forge-std/console.sol';\n\ncontract Project {\n\n    address public immutable creator;\n    \n    uint public immutable goal;\n    uint timeCreated = block.timestamp;\n\n    bool public goalFailed = false;\n    bool public goalAchieved = false;\n    \n    CrowdFunder nft;\n\n    mapping (address => uint) public contributions;\n    mapping (address => uint) public tokensOwed;\n    mapping (address => uint) public tokensClaimed;\n\n    modifier onlyCreator() {\n        require(msg.sender == creator, 'Only creator can call this function');\n        _;\n    }\n\n    function setGoalStatus() private {\n        if(goalAchieved || goalFailed) {\n            return;\n        } else if (block.timestamp > timeCreated + 30 days) {\n            goalFailed = true;\n        } else if (address(this).balance >= goal) {\n            goalAchieved = true;\n        }\n    }\n\n    constructor (uint _goal, string memory _name, string memory _symbol, address _creator) {\n        goal = _goal;\n        nft = new CrowdFunder(_name, _symbol);\n        creator = _creator;\n    }\n\n    function contribute () public payable {\n        \n        if (block.timestamp > timeCreated + 30 days) {\n            goalFailed = true;\n        } \n        \n        require(msg.value >= 0.01 ether, 'Not enough eth');\n        require(!(goalAchieved || goalFailed), 'Goal already achieved or failed');\n        contributions[msg.sender] += msg.value;\n\n        tokensOwed[msg.sender] = contributions[msg.sender] / 1 ether;\n\n        setGoalStatus();\n    }\n\n    function claimTokens () public  {\n        setGoalStatus();\n        uint numTokensToMint = tokensOwed[msg.sender] - tokensClaimed[msg.sender];\n        tokensClaimed[msg.sender] += numTokensToMint;\n        for (uint i = 0; i < numTokensToMint; i++) {\n            nft.mint(msg.sender);\n        }\n    }\n\n    function refund () public  {\n        setGoalStatus(); /* PLEASE HIT THIS LINE */\n        require(contributions[msg.sender] > 0, 'No contribution to refund'); /* PLEASE HIT THIS LINE */\n        require(goalFailed, 'Goal not failed'); /* PLEASE HIT THIS LINE */\n        uint refundAmount = contributions[msg.sender]; /* PLEASE HIT THIS LINE */\n        contributions[msg.sender] = 0; /* PLEASE HIT THIS LINE */\n        (bool success,) = payable(msg.sender).call{value: refundAmount}(''); /* PLEASE HIT THIS LINE */\n        require(success, 'Refund failed'); /* PLEASE HIT THIS LINE */\n    }  \n\n    function withdraw(uint amount) public onlyCreator() {\n        setGoalStatus();\n        require(goalAchieved, 'Goal not achieved');\n        require(amount <= address(this).balance, 'Not enough eth');\n        (bool success,) = payable(creator).call{value: amount}('');\n        require(success, 'Withdraw failed');\n    }\n\n    receive() external payable {\n        contribute();\n    }\n}",
        "output": "function testRefundSucess() public {\n        vm.startPrank(bob);\n        Project project = new Project(50 ether, 'Project', 'PJT', bob);\n        vm.stopPrank();\n\n        vm.deal(alice, 100 ether);\n        \n        vm.startPrank(alice);\n        project.contribute{value: 10 ether}();\n        vm.stopPrank(); \n\n        vm.warp(block.timestamp + 31 days);\n\n        vm.startPrank(alice);\n        project.refund();\n        vm.stopPrank(); \n    }"
    },
    {
        "input": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\nimport './CrowdFunder.sol';\nimport 'forge-std/console.sol';\n\ncontract Project {\n\n    address public immutable creator;\n    \n    uint public immutable goal;\n    uint timeCreated = block.timestamp;\n\n    bool public goalFailed = false;\n    bool public goalAchieved = false;\n    \n    CrowdFunder nft;\n\n    mapping (address => uint) public contributions;\n    mapping (address => uint) public tokensOwed;\n    mapping (address => uint) public tokensClaimed;\n\n    modifier onlyCreator() {\n        require(msg.sender == creator, 'Only creator can call this function');\n        _;\n    }\n\n    function setGoalStatus() private {\n        if(goalAchieved || goalFailed) {\n            return;\n        } else if (block.timestamp > timeCreated + 30 days) {\n            goalFailed = true;\n        } else if (address(this).balance >= goal) {\n            goalAchieved = true;\n        }\n    }\n\n    constructor (uint _goal, string memory _name, string memory _symbol, address _creator) {\n        goal = _goal;\n        nft = new CrowdFunder(_name, _symbol);\n        creator = _creator;\n    }\n\n    function contribute () public payable {\n        \n        if (block.timestamp > timeCreated + 30 days) {\n            goalFailed = true;\n        } \n        \n        require(msg.value >= 0.01 ether, 'Not enough eth');\n        require(!(goalAchieved || goalFailed), 'Goal already achieved or failed');\n        contributions[msg.sender] += msg.value;\n\n        tokensOwed[msg.sender] = contributions[msg.sender] / 1 ether;\n\n        setGoalStatus();\n    }\n\n    function claimTokens () public  {\n        setGoalStatus();\n        uint numTokensToMint = tokensOwed[msg.sender] - tokensClaimed[msg.sender];\n        tokensClaimed[msg.sender] += numTokensToMint;\n        for (uint i = 0; i < numTokensToMint; i++) {\n            nft.mint(msg.sender);\n        }\n    }\n\n    function refund () public  {\n        setGoalStatus();\n        require(contributions[msg.sender] > 0, 'No contribution to refund');\n        require(goalFailed, 'Goal not failed');\n        uint refundAmount = contributions[msg.sender];\n        contributions[msg.sender] = 0;\n        (bool success,) = payable(msg.sender).call{value: refundAmount}('');\n        require(success, 'Refund failed');\n    }  \n\n    function withdraw(uint amount) public onlyCreator() {\n        setGoalStatus(); /* PLEASE HIT THIS LINE */\n        require(goalAchieved, 'Goal not achieved'); /* PLEASE HIT THIS LINE */\n        require(amount <= address(this).balance, 'Not enough eth'); /* PLEASE HIT THIS LINE */\n        (bool success,) = payable(creator).call{value: amount}(''); /* PLEASE HIT THIS LINE */\n        require(success, 'Withdraw failed'); /* PLEASE HIT THIS LINE */\n    }\n\n    receive() external payable {\n        contribute();\n    }\n}",
        "output":"function testWithdrawSuccess() public {\n        vm.startPrank(bob);\n        Project project = new Project(50 ether, 'Project', 'PJT', bob);\n        vm.stopPrank();\n\n        vm.deal(alice, 100 ether);\n        \n        vm.startPrank(alice);\n        project.contribute{value: 50 ether}();\n        vm.stopPrank(); \n\n        vm.startPrank(bob);\n        project.withdraw(30 ether);\n        vm.stopPrank();  \n    }"
    }
]